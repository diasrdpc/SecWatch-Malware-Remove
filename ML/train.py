import os
import random
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.models import Sequential
import numpy as np
from PIL import Image

NNSIZE = 128

# Define the function to convert binary data to 512x512 images
def get_resized_image_data(file_path, target_size=(NNSIZE, NNSIZE)):
    try:
        print(f"Reading file: {file_path}")
        # Read binary data from the file
        with open(file_path, 'rb') as file:
            binary_data = file.read()

        # Calculate the size of the square image
        data_len = len(binary_data)
        side_length = int(data_len ** 0.5)
        if side_length * side_length < data_len:
            side_length += 1

        # Create a new image with white background
        image = Image.new('RGB', (side_length, side_length), (255, 255, 255))

        # Copy the binary data to the image
        for i in range(data_len):
            x = i % side_length
            y = i // side_length
            pixel_value = int.from_bytes(binary_data[i:i+1], byteorder='big')
            image.putpixel((x, y), (pixel_value, pixel_value, pixel_value))

        # Resize the image to the target size (512x512)
        resized_image = image.resize(target_size)

        # Convert the resized image to numpy array
        image_data = np.array(resized_image)

        return image_data
    except Exception as e:
        print(f"Error in get_resized_image_data for file {file_path}: {e}")
        return None

# Define your data directories
malware_dir = 'malware/'
not_malware_dir = 'not-malware/'

# Create a list to store image data and labels
data = []
labels = []

# Process the "malware" folder
for filename in os.listdir(malware_dir):
    file_path = os.path.join(malware_dir, filename)
    image_data = get_resized_image_data(file_path)
    if image_data is not None:
        data.append(image_data)
        labels.append(1)  # 1 represents "malware"

# Process the "not-malware" folder
for filename in os.listdir(not_malware_dir):
    file_path = os.path.join(not_malware_dir, filename)
    image_data = get_resized_image_data(file_path)
    if image_data is not None:
        data.append(image_data)
        labels.append(0)  # 0 represents "not-malware"

# Shuffle the data
combined = list(zip(data, labels))
random.shuffle(combined)
data, labels = zip(*combined)

# Split data into training and testing sets (e.g., 80% for training and 20% for testing)
split_idx = int(0.8 * len(data))
train_data, test_data = data[:split_idx], data[split_idx:]
train_labels, test_labels = labels[:split_idx], labels[split_idx:]

# Convert the data and labels to numpy arrays
train_data = np.array(train_data)
test_data = np.array(test_data)
train_labels = np.array(train_labels)
test_labels = np.array(test_labels)

print("Data preprocessing complete.")

# Define the CNN model
model = Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(NNSIZE, NNSIZE, 3)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

print("Model defined.")

# Train the model
model.fit(train_data, train_labels, epochs=100, validation_data=(test_data, test_labels))

print("Model training complete.")

# Evaluate the model
test_loss, test_acc = model.evaluate(test_data, test_labels)
print(f"Test accuracy: {test_acc}")

# Save the model
model.save('malware_detection_model.h5')
print("Model saved as malware_detection_model.h5.")
